<!-- c++ switch-case statement discussion -->
  <div class="container py-4">
    <h1>C++ <code>switch</code> / <code>case</code></h1>

    <!-- What is switch -->
    <div class="card mb-3">
      <div class="card-header">What Is a <code>switch</code> Statement?</div>
      <div class="card-body">
        <p>
          A <code>switch</code> selects one of several branches based on the value of a single expression.
          Each branch is labeled with a constant <code>case</code> value; an optional <code>default</code> handles “none of the above.”
        </p>
<pre><code class="language-cpp">// Basic shape
switch (expr) {
  case CONST_1:
    // do something
    break;               // prevents fall-through
  case CONST_2:
    // do something else
    break;
  default:
    // fallback if no case matches
}
</code></pre>
        <ul class="mb-0">
          <li>The value in <code>switch ( ... )</code> is evaluated once.</li>
          <li>Execution jumps to the first matching <code>case</code> label.</li>
          <li>Use <code>break;</code> to end a branch; otherwise control continues into the next label (fall-through).</li>
        </ul>
      </div>
    </div>

    <!-- Valid types -->
    <div class="card mb-3">
      <div class="card-header">What Types Can Be Used in <code>switch</code>?</div>
      <div class="card-body">
        <p>For now, think of <code>switch</code> as working with <strong>whole-number and character types</strong>:</p>
        <ul>
          <li><strong>OK:</strong> <code>int</code>, <code>short</code>, <code>long</code>, <code>char</code>, and <code>bool</code> (it behaves like an <code>int</code> under the hood).</li>
          <li><strong>Not OK:</strong> <code>float</code>, <code>double</code>, and <code>std::string</code> (or other objects).</li>
        </ul>
        <p class="mb-0">Case labels must be <em>constant</em> values known at compile time (e.g., <code>0</code>, <code>'y'</code>, <code>42</code>).</p>
<pre><code class="language-cpp">char cmd = 's';
switch (cmd) {
  case 'n': /* New */  break;
  case 's': /* Save */ break;
  case 'q': /* Quit */ break;
  default:  /* Fallback */
}
</code></pre>
      </div> <!-- card-body -->
    </div> <!-- card -->

    <!-- Fall-through -->
    <div class="card mb-3">
      <div class="card-header">What Is Fall-Through?</div>
      <div class="card-body">
        <p>
          If a <code>case</code> block does not end with <code>break</code> (or <code>return</code>, <code>throw</code>, etc.), execution continues into the next <code>case</code> label. This is called <em>fall-through</em>.
        </p>
<pre><code class="language-cpp">int day = 6; // 1=Mon ... 7=Sun
switch (day) {
  case 6:
  case 7:
    std::cout &lt;&lt; "Weekend\n";  // day==6 will fall through to here
    break;
  default:
    std::cout &lt;&lt; "Weekday\n";
}
</code></pre>
        <p class="mb-0">
          In C++17 and later, mark <em>intentional</em> fall-through with <code>[[fallthrough]];</code> for clarity.
        </p>
<pre class="mb-0"><code class="language-cpp">switch (code) {
  case 1:
    handleMinor();
    [[fallthrough]]; // C++17+
  case 2:
    handleMajor();
    break;
}
</code></pre>
      </div>
    </div>

    <!-- When to use -->
    <div class="card mb-3">
      <div class="card-header">When Should You Use <code>switch</code>?</div>
      <div class="card-body">
        <ul>
          <li>Branching on a <strong>single discrete value</strong> with a small/medium set of <strong>constant</strong> options.</li>
          <li>Cases are <strong>mutually exclusive</strong> and there’s a sensible <code>default</code>.</li>
          <li>Prefer a <strong>clean, readable</strong> alternative to a long chain of equality checks.</li>
        </ul>
<pre><code class="language-cpp">char cmd = 's';
switch (cmd) {
  case 'n': std::cout &lt;&lt; "New\n"; break;
  case 's': std::cout &lt;&lt; "Save\n"; break;
  case 'q': std::cout &lt;&lt; "Quit\n"; break;
  default:  std::cout &lt;&lt; "Unknown command\n"; break;
}
</code></pre>
      </div>
    </div>

    <!-- Why not if/else -->
    <div class="card mb-3">
      <div class="card-header">Why Not Just Use <code>if</code> / <code>else if</code>?</div>
      <div class="card-body">
        <ul>
          <li><strong>Readability:</strong> With many discrete constant cases, <code>switch</code> is often clearer and more compact.</li>
          <li><strong>Intent:</strong> Emphasizes selecting one of many constant options.</li>
          <li><strong>Maintainability:</strong> Adding a new option is just another <code>case</code>.</li>
        </ul>
        <p class="mb-1"><strong>Use <code>if/else</code> instead when:</strong></p>
        <ul class="mb-0">
          <li>You need <strong>ranges</strong> or complex boolean logic (e.g., <code>x &gt;= 10 &amp;&amp; y &lt; z</code>).</li>
          <li>You compare <strong>non-integral</strong> data (e.g., strings) or need runtime-computed conditions for labels.</li>
        </ul>
      </div>
    </div>

    <!-- Tips & pitfalls -->
    <div class="card mb-4">
      <div class="card-header">Helpful Hints</div>
      <div class="card-body">
        <ul class="mb-0">
          <li>Include a <code>default</code> to handle unexpected values.</li>
          <li>End each case with <code>break;</code> unless you <em>want</em> fall-through (then consider <code>[[fallthrough]];</code>).</li>
          <li>Ensure <code>case</code> labels are unique and are compile-time constants.</li>
          <li>For <code>enum class</code>, qualify labels (e.g., <code>Color::Red</code>).</li>
        </ul>
      </div>
    </div>

  </div> <!-- container -->