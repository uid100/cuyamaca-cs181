<div class="container my-4">
    <!-- Page Header -->
    <div class="row g-4">
      <div class="col-12">
        <div class="card shadow-sm">
          <div class="card-body">
            <h1 class="card-title h3">C++ Data Types — Why They Matter</h1>
            <p class="card-text">
              In C++, <strong>data types</strong> tell the compiler how much <em>memory</em> to reserve, how to interpret the bits stored,
              and which <em>operations</em> are valid for those values. Choosing the correct type improves
              <strong>performance</strong>, <strong>correctness</strong>, and <strong>portability</strong>.
            </p>
            <ul>
              <li><strong>Memory layout:</strong> The compiler needs to know how many bytes to allocate (<code>sizeof(T)</code>) for each variable.</li>
              <li><strong>Rules & operations:</strong> Each type has allowed operations (e.g., arithmetic on integers; logical on <code>bool</code>).</li>
              <li><strong>Conversions:</strong> Values sometimes convert automatically (implicit) or require explicit casts—some are <em>unsafe</em> or disallowed.</li>
            </ul>
            <p class="mb-0"><em>Tip:</em> Use <code>sizeof(T)</code> in code to learn sizes on your specific platform; sizes are
              implementation-defined (except for certain minimums).</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Primitive Types Overview -->
    <div class="row g-4 mt-1">
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Primitive (Fundamental) Types</h2>
            <p class="mb-1">Core categories you’ll use daily:</p>
            <div class="mb-2">
              <span class="pill">bool</span>
              <span class="pill">char</span>
              <span class="pill">signed/unsigned char</span>
              <span class="pill">wchar_t</span>
              <span class="pill">char8_t</span>
              <span class="pill">char16_t</span>
              <span class="pill">char32_t</span>
            </div>
            <div class="mb-2">
              <span class="pill">short</span>
              <span class="pill">int</span>
              <span class="pill">long</span>
              <span class="pill">long long</span>
              <span class="pill">signed / unsigned</span>
            </div>
            <div class="mb-2">
              <span class="pill">float</span>
              <span class="pill">double</span>
              <span class="pill">long double</span>
            </div>
            <div class="mb-2">
              <span class="pill">std::nullptr_t</span>
            </div>
            <p class="mb-0">
              For fixed-width integers, prefer <code>&lt;cstdint&gt;</code> types:
              <span class="pill">std::int8_t</span>
              <span class="pill">std::int16_t</span>
              <span class="pill">std::int32_t</span>
              <span class="pill">std::int64_t</span>
              <span class="pill">std::uint8_t</span>
              <span class="pill">…</span>
            </p>
          </div>
        </div>
      </div>

      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Why Sizes Vary</h2>
            <p>
              C++ guarantees <em>minimum</em> sizes and relationships (e.g., <code>sizeof(short) ≤ sizeof(int) ≤ sizeof(long)</code>)
              but not exact byte counts across platforms. Use <code>sizeof</code> to verify on your machine.
            </p>
<pre><code class="language-cpp">// Check sizes on your platform
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
int main() {
    std::cout &lt;&lt; "sizeof(bool) = " &lt;&lt; sizeof(bool) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(char) = " &lt;&lt; sizeof(char) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(short) = " &lt;&lt; sizeof(short) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(long) = " &lt;&lt; sizeof(long) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(long long) = " &lt;&lt; sizeof(long long) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(float) = " &lt;&lt; sizeof(float) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(double) = " &lt;&lt; sizeof(double) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(long double) = " &lt;&lt; sizeof(long double) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(int32_t) = " &lt;&lt; sizeof(std::int32_t) &lt;&lt; '\n';
}
</code></pre>
            <div class="code-caption">Run this to see the actual sizes on your compiler/OS/ABI.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Integers Card -->
    <div class="row g-4 mt-1">
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Integer Types & Rules</h2>
            <ul>
              <li><strong>Signed vs. Unsigned:</strong> Unsigned types wrap modulo 2<sup>N</sup>; <em>signed overflow is undefined behavior</em>.</li>
              <li><strong>Usual arithmetic conversions:</strong> Mixed arithmetic promotes to a common type (often <code>int</code> or wider).</li>
              <li><strong>Literals:</strong> Suffixes control type: <code>42u</code> (<em>unsigned</em>), <code>42L</code> (<em>long</em>), <code>42LL</code> (<em>long long</em>).</li>
              <li><strong>Binary/Hex:</strong> <code>0b1010</code>, <code>0xFF</code> (C++14+ binary literals).</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    unsigned int u = 0;
    u = u - 1; // wraps to max unsigned value (defined behavior)
    std::cout &lt;&lt; u &lt;&lt; '\n';

    int a = 2'000'000'000; // digit separators
    int b = 2'000'000'000;
    // int c = a + b; // may overflow: undefined behavior for signed overflow

    unsigned long ul = 42uL;
    auto hex = 0xFFu;  // 255
    auto bin = 0b1010; // 10
}
</code></pre>
          </div>
        </div>
      </div>

      <!-- Floating-Point Card -->
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Floating-Point Types & Rules</h2>
            <ul>
              <li><code>float</code>, <code>double</code>, <code>long double</code> (precision increases in that order, but exact precision is platform-dependent).</li>
              <li>Rounding errors occur; compare with a tolerance, not <code>==</code>.</li>
              <li>Literals: <code>1.0f</code> (<em>float</em>), <code>1.0</code> (<em>double</em>), <code>1.0L</code> (<em>long double</em>).</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
int main() {
    double x = 0.1 + 0.2;   // not exactly 0.3 due to binary representation
    double y = 0.3;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; (std::fabs(x - y) &lt; 1e-12) &lt;&lt; '\n'; // true
}
</code></pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Char & Bool -->
    <div class="row g-4 mt-1">
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4"><code>char</code>, Wide/UTF Chars & <code>bool</code></h2>
            <ul>
              <li><code>char</code> is an integer type (signedness is implementation-defined). Use <code>signed char</code> / <code>unsigned char</code> to be explicit.</li>
              <li>Unicode code units:
                <code>char8_t</code> (UTF-8, C++20),
                <code>char16_t</code> (UTF-16),
                <code>char32_t</code> (UTF-32),
                and <code>wchar_t</code> (width varies by platform).
              </li>
              <li><code>bool</code> stores <code>true</code> or <code>false</code>; implicit conversions treat 0 as false, non-zero as true.</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    char c = 'A';
    bool flag1 = 42;   // true (non-zero converts to true)
    bool flag2 = 0;    // false

    char16_t u = u'\u03A9'; // Greek capital omega (Ω)
    std::cout &lt;&lt; std::boolalpha &lt;&lt; flag1 &lt;&lt; ", " &lt;&lt; flag2 &lt;&lt; '\n';
}
</code></pre>
          </div>
        </div>
      </div>

      <!-- Literals & Suffixes -->
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Literals & Suffixes (Quick Guide)</h2>
            <ul class="mb-2">
              <li>Integer: <code>42</code> (<em>int</em>), <code>42u</code> (<em>unsigned</em>), <code>42L</code>, <code>42LL</code>, <code>0x2A</code>, <code>0b101010</code>.</li>
              <li>Floating: <code>3.14</code> (<em>double</em>), <code>3.14f</code> (<em>float</em>), <code>3.14L</code> (<em>long double</em>).</li>
              <li>Char/String encodings: <code>u8"…"</code>, <code>u"…"</code>, <code>U"…"</code>, <code>L"…"</code>.</li>
            </ul>
<pre><code class="language-cpp">auto a = 42;      // int
auto b = 42u;     // unsigned
auto c = 3.14;    // double
auto d = 3.14f;   // float
auto e = u8"UTF-8"; // const char8_t*
</code></pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Rules & Pitfalls -->
    <div class="row g-4 mt-1">
      <div class="col-lg-12">
        <div class="card shadow-sm">
          <div class="card-body">
            <h2 class="card-title h4">Key Rules & Common Pitfalls</h2>
            <ul>
              <li><strong>Narrowing conversions:</strong> Brace-initialization forbids them at compile time (good!).</li>
              <li><strong>Signed overflow:</strong> Undefined behavior. <em>Do not rely</em> on wrapping.</li>
              <li><strong>Division by zero:</strong> Undefined for integers; floating-point may produce <code>inf</code>/NaN.</li>
              <li><strong>Char signedness:</strong> Varies by platform; don’t depend on <code>char</code> being signed or unsigned.</li>
            </ul>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
int main() {
    double pi = 3.14159;
    int x1 = (int)pi;        // allowed (explicit C-style cast), truncates to 3
    int x2 = static_cast&lt;int&gt;(pi); // preferred explicit cast

    // int bad{pi}; // error: narrowing conversion prevented by brace-init

    unsigned int u = 0;
    // int neg = -1;
    // u = neg; // allowed but value may surprise; results in large unsigned value

    // int overflow = 2'000'000'000 + 2'000'000'000; // undefined behavior (signed overflow)
}
</code></pre>
            <div class="alert alert-warning mb-0">
              <strong>Remember:</strong> Prefer explicit casts when semantics are clear. Use brace-initialization to <em>catch</em> narrowing errors.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Type Casting -->
    <div class="row g-4 mt-1">
      <div class="col-lg-12">
        <div class="card shadow-sm">
          <div class="card-body">
            <h2 class="card-title h4">Type Casting in C++: Implicit vs. Explicit</h2>

            <h3 class="h5 mt-3">Implicit Conversions (Happen Automatically)</h3>
            <ul>
              <li><strong>Widening numeric conversions</strong> (e.g., <code>int</code> → <code>double</code>) are generally safe.</li>
              <li><strong>Integer promotions</strong> (e.g., <code>char</code>/<code>short</code> → <code>int</code>) during arithmetic.</li>
              <li><strong>Boolean conversions:</strong> zero → <code>false</code>, non-zero → <code>true</code>.</li>
              <li><strong>Pointer</strong> <code>nullptr</code> converts to any pointer type.</li>
            </ul>
<pre><code class="language-cpp">int   i = 10;
double d = i;        // implicit: int -> double
bool  b = d;         // implicit: non-zero -> true
const char* s = nullptr; // implicit: nullptr -> const char*
</code></pre>

            <h3 class="h5 mt-4">Explicit Casts (You Must Ask For Them)</h3>
            <ul>
              <li><code>static_cast&lt;T&gt;(expr)</code> — value conversions (numeric types, pointers in safe hierarchies, enum ↔ integer); checks at compile time where possible.</li>
              <li><code>const_cast&lt;T&gt;(expr)</code> — adds/removes <code>const</code>/<code>volatile</code> qualifiers (dangerous if you modify an originally-const object).</li>
              <li><code>reinterpret_cast&lt;T&gt;(expr)</code> — reinterprets bit patterns; <em>non-portable</em> and dangerous; use sparingly.</li>
              <li>C-style/functional cast (<code>(T)expr</code> or <code>T(expr)</code>) — performs a sequence of conversions; <em>discouraged</em> because it’s less explicit.</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
struct Base { virtual ~Base() = default; };
struct Derived : Base { void f() {} };

int main() {
    double d = 3.99;
    int i = static_cast&lt;int&gt;(d); // 3 (truncates)

    const int ci = 42;
    // int* p = &amp;ci;               // error
    const int* cpi = &amp;ci;
    int* p2 = const_cast&lt;int*&gt;(cpi); // compiles
    // *p2 = 7; // ⚠️ Undefined behavior if 'ci' is truly const storage

    Base* b = new Derived;
    // static_cast between base/derived pointers allowed in hierarchies:
    Derived* dp = static_cast&lt;Derived*&gt;(b); // OK if 'b' actually points to Derived
    dp-&gt;f(); // OK here

    // Dangerous: reinterpret bits as unrelated type
    std::uintptr_t raw = reinterpret_cast&lt;std::uintptr_t&gt;(dp); // address as integer
    Derived* fromNum = reinterpret_cast&lt;Derived*&gt;(raw);        // non-portable; avoid
    delete b;
}
</code></pre>

            <div class="row g-3">
              <div class="col-lg-6">
                <div class="border rounded p-3 h-100">
                  <h4 class="h6">✅ Commonly Allowed & Reasonable</h4>
                  <ul class="mb-0">
                    <li><code>static_cast&lt;double&gt;(intVal)</code> — widening conversion.</li>
                    <li><code>static_cast&lt;int&gt;(doubleVal)</code> — truncates; explicit on purpose.</li>
                    <li><code>static_cast&lt;base*&gt;(derivedPtr)</code> — upcast in class hierarchy.</li>
                    <li><code>const_cast&lt;T*&gt;</code> — only to call legacy APIs that require non-const (don’t modify truly-const objects).</li>
                  </ul>
                </div>
              </div>
              <div class="col-lg-6">
                <div class="border rounded p-3 h-100">
                  <h4 class="h6">⛔ Discouraged / Not Allowed / Dangerous</h4>
                  <ul class="mb-0">
                    <li><strong>Signed overflow</strong> — undefined behavior; not a “cast” problem but a frequent outcome of bad conversions.</li>
                    <li><code>reinterpret_cast</code> between unrelated pointer types — non-portable, can break strict aliasing.</li>
                    <li><code>const_cast</code> to modify an originally-<code>const</code> object — undefined behavior.</li>
                    <li>C-style casts that hide what’s happening — prefer <code>static_cast</code>/<code>const_cast</code>/<code>reinterpret_cast</code>.</li>
                  </ul>
                </div>
              </div>
            </div>

            <h3 class="h5 mt-4">Narrowing: What the Compiler Forbids</h3>
<pre><code class="language-cpp">double pi = 3.14159;
// int i{pi};        // ❌ compile-time error: narrowing with brace-init
int j = (int)pi;     // ✅ compiles (C-style), but truncates (explicit)
int k = static_cast&lt;int&gt;(pi); // ✅ compiles, explicit and clear
</code></pre>
            <div class="alert alert-info mb-0">
              <strong>Rule of thumb:</strong> If a conversion might lose information, make it <em>explicit</em> and prefer <code>static_cast</code>.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Practice & Examples -->
    <div class="row g-4 mt-1">
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Practice: Spot the Issue</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    unsigned int u = 10;
    int s = -1;

    auto r1 = u + s;     // what type? what value?
    std::cout &lt;&lt; r1 &lt;&lt; '\n';

    int big = 3'000'000'000; // fits in 32-bit unsigned, but not 32-bit signed
    std::cout &lt;&lt; big &lt;&lt; '\n'; // what happens?

    float f = 1e39f;     // overflow to inf on typical IEEE-754 float
    std::cout &lt;&lt; f &lt;&lt; '\n';
}
</code></pre>
            <ul class="mb-0">
              <li>Mixed signed/unsigned arithmetic can surprise you (usual arithmetic conversions).</li>
              <li>Integer literal types depend on magnitude and suffix; choose the right type.</li>
              <li>Floating overflow/underflow produce <code>inf</code>/0.0, not compile errors.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Suggested Subpages -->
      <div class="col-lg-6">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h2 class="card-title h4">Recommended Subpages (for Smaller Lessons)</h2>
            <ol class="mb-3">
              <li><strong>Primitive Types Deep Dive:</strong> <code>bool</code>, <code>char</code> family, integers, floating point.</li>
              <li><strong>Integer Ranges & Overflow:</strong> signed vs. unsigned, fixed-width types, safe arithmetic.</li>
              <li><strong>Floating-Point Essentials:</strong> precision, rounding, comparisons, NaN/inf, <code>std::numeric_limits</code>.</li>
              <li><strong>Literals & Suffixes:</strong> integer & FP literals, digit separators, character/UTF encodings.</li>
              <li><strong>Type Conversions & Casting:</strong> implicit vs. explicit, <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>, pitfalls.</li>
              <li><strong>Memory & <code>sizeof</code> Lab:</strong> measure sizes, alignments, ABI differences, portability tips.</li>
            </ol>
            <p class="mb-0"><em>Optional:</em> Add exercises and auto-graded checks (e.g., detect narrowing or overflow) per subpage.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="text-center text-muted small mt-4">
      <hr />
      <p class="mb-1">C++ examples are portable but sizes and exact FP behavior depend on platform and compiler.</p>
      <p class="mb-0">Use <code>-std=c++17</code> or later for binary literals and <code>char8_t</code> (C++20).</p>
    </div>
</div> <!-- container -->