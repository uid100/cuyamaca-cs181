<div class="container my-4">
    <!-- Page Header -->
    <div class="card shadow-sm">
        <div class="card-header">C++ Data Types</div>
        <div class="card-body">
            <h1 class="card-title h3">Data Types — Why They Matter</h1>
            <p class="card-text">
                In C++, <strong>data types</strong> tell the compiler how much <em>memory</em> to reserve, 
                how to interpret the bits stored,
                and which <em>operations</em> are valid for those values. Choosing the correct type improves
                <strong>performance</strong>, <strong>correctness</strong>, and <strong>portability</strong>.
            </p>
            <ul>
                <li><strong>Memory layout:</strong> The compiler needs to know how many bytes to allocate 
                    (<code>sizeof(T)</code>) for each variable.</li>
                <li><strong>Rules & operations:</strong> Each type has allowed operations (e.g., arithmetic 
                    on integers; logical on <code>bool</code>).</li>
                <li><strong>Conversions:</strong> Values sometimes convert automatically (implicit) or require 
                    explicit casts—some are <em>unsafe</em> or disallowed.</li>
            </ul>
            <p class="mb-0"><em>Tip:</em> Use <code>sizeof(T)</code> in code to learn sizes on your specific 
                platform; sizes are implementation-defined (except for certain minimums).</p>
        </div> <!-- card-body -->
    </div> <!-- card -->

    <!-- Primitive Types Overview -->
    <div class="card shadow-sm">
        <div class="card-header">Primitive Types</div>
        <div class="card-body">
            <h2 class="card-title h4">Primitive (Fundamental) Types</h2>
            <p class="mb-1">Core categories:</p>

            <ul class="mb-3">
            <li>
                <strong>Boolean and character types</strong>
                <ul>
                <li><code>bool</code></li>
                <li><code>char</code></li>
                <li><code>signed char</code>, <code>unsigned char</code></li>
                <li><code>wchar_t</code></li>
                <li><code>char8_t</code></li>
                <li><code>char16_t</code></li>
                <li><code>char32_t</code></li>
                </ul>
            </li>

            <p class="border italic">Why do we need these different character types?</p>

            <li>
                <strong>Integer types</strong>
                <ul>
                <li><code>short</code></li>
                <li><code>int</code></li>
                <li><code>long</code></li>
                <li><code>long long</code></li>
                <li><code>signed</code> / <code>unsigned</code> variants</li>
                </ul>
            </li>

            <li>
                <strong>Floating-point types</strong>
                <ul>
                <li><code>float</code></li>
                <li><code>double</code></li>
                <li><code>long double</code></li>
                </ul>
            </li>

            <p class="border italic">Why so many numeric types?</p>
            
            <li style="font-style: italic;">
                <strong>other:</strong>
                <ul>
                    <li><code>std::nullptr_t</code></li>
                    <li><code>std::int8_t</code></li>
                    <li><code>std::int16_t</code></li>
                    <li><code>std::int32_t</code></li>
                    <li><code>std::int64_t</code></li>
                    <li><code>std::uint8_t</code></li>
                    <li>…</li>
                </ul>
            </li>
        </ul>
        <p class="border italic">What does primitive mean in this context?</p>
        </div> <!-- card-body -->
    </div>  <!-- card -->

    <!-- sizes -->
    <div class="card shadow-sm">
        <div class="card-header">Why?</div>
        <div class="card-body">
        <h2 class="card-title h4">Why Sizes Vary</h2>
        <p>
            C++ guarantees <em>minimum</em> sizes and relationships (e.g., <code>sizeof(short) ≤ sizeof(int) ≤ sizeof(long)</code>)
            but not exact byte counts across platforms. Use <code>sizeof</code> to verify on your machine.
        </p>

<pre><code class="language-cpp">// Check sizes on your platform
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
int main() {
std::cout &lt;&lt; "sizeof(bool) = " &lt;&lt; sizeof(bool) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(char) = " &lt;&lt; sizeof(char) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(short) = " &lt;&lt; sizeof(short) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(long) = " &lt;&lt; sizeof(long) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(long long) = " &lt;&lt; sizeof(long long) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(float) = " &lt;&lt; sizeof(float) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(double) = " &lt;&lt; sizeof(double) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(long double) = " &lt;&lt; sizeof(long double) &lt;&lt; '\n';
std::cout &lt;&lt; "sizeof(int32_t) = " &lt;&lt; sizeof(std::int32_t) &lt;&lt; '\n';
}
</code></pre>
        <div class="code-caption">Run this to see the actual sizes on your compiler/OS/ABI.</div>
        </div> <!-- card-body -->
    </div> <!-- card -->

    <!-- Integers Card -->
    <div class="card shadow-sm h-100">
        <div class="card-header">Integers</div>
        <div class="card-body">
            <h2 class="card-title h4">Integer Types & Rules</h2>
            <ul>
            <li><strong>Signed vs. Unsigned:</strong> Unsigned types wrap modulo 2<sup>N</sup>; <em>signed overflow is undefined behavior</em>.</li>
            <li><strong>Usual arithmetic conversions:</strong> Mixed arithmetic promotes to a common type (often <code>int</code> or wider).</li>
            <li><strong>Literals:</strong> Suffixes control type: <code>42u</code> (<em>unsigned</em>), <code>42L</code> (<em>long</em>), <code>42LL</code> (<em>long long</em>).</li>
            <li><strong>Binary/Hex:</strong> <code>0b1010</code>, <code>0xFF</code> (C++14+ binary literals).</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
unsigned int u = 0;
u = u - 1; // wraps to max unsigned value (defined behavior)
std::cout &lt;&lt; u &lt;&lt; '\n';

int a = 2'000'000'000; // digit separators
int b = 2'000'000'000;
// int c = a + b; // may overflow: undefined behavior for signed overflow

unsigned long ul = 42uL;
auto hex = 0xFFu;  // 255
auto bin = 0b1010; // 10
}
</code></pre>
        </div> <!-- card-body -->
    </div> <!-- card -->

      <!-- Floating-Point Card -->
    <div class="card shadow-sm h-100">
        <div class="card-header">float</div>
        <div class="card-body">
            <h2 class="card-title h4">Floating-Point Types & Rules</h2>
            <ul>
                <li><code>float</code>, <code>double</code>, <code>long double</code> (precision increases in that order, but exact precision is platform-dependent).</li>
                <li>Rounding errors occur; compare with a tolerance, not <code>==</code>.</li>
                <li>Literals: <code>1.0f</code> (<em>float</em>), <code>1.0</code> (<em>double</em>), <code>1.0L</code> (<em>long double</em>).</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
int main() {
double x = 0.1 + 0.2;   // not exactly 0.3 due to binary representation
double y = 0.3;
std::cout &lt;&lt; std::boolalpha &lt;&lt; (std::fabs(x - y) &lt; 1e-12) &lt;&lt; '\n'; // true
}
</code></pre>
        </div> <!-- card-body -->
    </div> <!-- card -->

    <!-- Char & Bool -->
    <div class="card shadow-sm">
        <div class="card-header"><code>char</code> & <code>bool</code></div>
        <div class="card-body">
            <h2 class="card-title h4"><code>char</code>, Wide/UTF Chars & <code>bool</code></h2>
            <ul>
            <li><code>char</code> is an integer type (signedness is implementation-defined). Use <code>signed char</code> / <code>unsigned char</code> to be explicit.</li>
            <li>Unicode code units:
                <code>char8_t</code> (UTF-8, C++20),
                <code>char16_t</code> (UTF-16),
                <code>char32_t</code> (UTF-32),
                and <code>wchar_t</code> (width varies by platform).
            </li>
            <li><code>bool</code> stores <code>true</code> or <code>false</code>; implicit conversions treat 0 as false, non-zero as true.</li>
            </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
char c = 'A';
bool flag1 = 42;   // true (non-zero converts to true)
bool flag2 = 0;    // false

char16_t u = u'\u03A9'; // Greek capital omega (Ω)
std::cout &lt;&lt; std::boolalpha &lt;&lt; flag1 &lt;&lt; ", " &lt;&lt; flag2 &lt;&lt; '\n';
}
</code></pre>
        </div>
    </div> <!-- card -->

      <!-- Literals & Suffixes -->
    <div class="card shadow-sm h-100">
        <div class="card-header">Literals</div>
        <div class="card-body">
            <h2 class="card-title h4">Literals & Suffixes (Quick Guide)</h2>
            <ul class="mb-2">
                <li>Integer: <code>42</code> (<em>int</em>), <code>42u</code> (<em>unsigned</em>), <code>42L</code>, <code>42LL</code>, <code>0x2A</code>, <code>0b101010</code>.</li>
                <li>Floating: <code>3.14</code> (<em>double</em>), <code>3.14f</code> (<em>float</em>), <code>3.14L</code> (<em>long double</em>).</li>
                <li>Char/String encodings: <code>u8"…"</code>, <code>u"…"</code>, <code>U"…"</code>, <code>L"…"</code>.</li>
            </ul>
<pre><code class="language-cpp">auto a = 42;      // int
auto b = 42u;     // unsigned
auto c = 3.14;    // double
auto d = 3.14f;   // float
auto e = u8"UTF-8"; // const char8_t*
</code></pre>
        </div> <!-- card-body -->
    </div> <!-- card -->

    <!-- Rules & Pitfalls -->
    <div class="card shadow-sm">
        <div class="card-body">
        <h2 class="card-title h4">Key Rules & Common Pitfalls</h2>
        <ul>
            <li><strong>Narrowing conversions:</strong> Brace-initialization forbids them at compile time (good!).</li>
            <li><strong>Signed overflow:</strong> Undefined behavior. <em>Do not rely</em> on wrapping.</li>
            <li><strong>Division by zero:</strong> Undefined for integers; floating-point may produce <code>inf</code>/NaN.</li>
            <li><strong>Char signedness:</strong> Varies by platform; don’t depend on <code>char</code> being signed or unsigned.</li>
        </ul>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
int main() {
double pi = 3.14159;
int x1 = (int)pi;        // allowed (explicit C-style cast), truncates to 3
int x2 = static_cast&lt;int&gt;(pi); // preferred explicit cast

// int bad{pi}; // error: narrowing conversion prevented by brace-init

unsigned int u = 0;
// int neg = -1;
// u = neg; // allowed but value may surprise; results in large unsigned value

// int overflow = 2'000'000'000 + 2'000'000'000; // undefined behavior (signed overflow)
}
</code></pre>
        <div class="alert alert-warning mb-0">
            <strong>Remember:</strong> Prefer explicit casts when semantics are clear. Use brace-initialization to <em>catch</em> narrowing errors.
        </div>
        </div>
    </div> <!-- card -->

    <!-- Type Casting -->
    <div class="card shadow-sm">
        <div class="card-body">
        <h2 class="card-title h4">Type Casting in C++: Implicit vs. Explicit</h2>

        <h3 class="h5 mt-3">Implicit Conversions (Happen Automatically)</h3>
        <ul>
            <li><strong>Widening numeric conversions</strong> (e.g., <code>int</code> → <code>double</code>) are generally safe.</li>
            <li><strong>Integer promotions</strong> (e.g., <code>char</code>/<code>short</code> → <code>int</code>) during arithmetic.</li>
            <li><strong>Boolean conversions:</strong> zero → <code>false</code>, non-zero → <code>true</code>.</li>
            <li><strong>Pointer</strong> <code>nullptr</code> converts to any pointer type.</li>
        </ul>
<pre><code class="language-cpp">int   i = 10;
double d = i;        // implicit: int -> double
bool  b = d;         // implicit: non-zero -> true
const char* s = nullptr; // implicit: nullptr -> const char*
</code></pre>

        <h3 class="h5 mt-4">Explicit Casts (You Must Ask For Them)</h3>
        <ul>
            <li><code>static_cast&lt;T&gt;(expr)</code> — value conversions (numeric types, pointers in safe hierarchies, enum ↔ integer); checks at compile time where possible.</li>
            <li><code>const_cast&lt;T&gt;(expr)</code> — adds/removes <code>const</code>/<code>volatile</code> qualifiers (dangerous if you modify an originally-const object).</li>
            <li><code>reinterpret_cast&lt;T&gt;(expr)</code> — reinterprets bit patterns; <em>non-portable</em> and dangerous; use sparingly.</li>
            <li>C-style/functional cast (<code>(T)expr</code> or <code>T(expr)</code>) — performs a sequence of conversions; <em>discouraged</em> because it’s less explicit.</li>
        </ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
struct Base { virtual ~Base() = default; };
struct Derived : Base { void f() {} };

int main() {
double d = 3.99;
int i = static_cast&lt;int&gt;(d); // 3 (truncates)

const int ci = 42;
// int* p = &amp;ci;               // error
const int* cpi = &amp;ci;
int* p2 = const_cast&lt;int*&gt;(cpi); // compiles
// *p2 = 7; // ⚠️ Undefined behavior if 'ci' is truly const storage

Base* b = new Derived;
// static_cast between base/derived pointers allowed in hierarchies:
Derived* dp = static_cast&lt;Derived*&gt;(b); // OK if 'b' actually points to Derived
dp-&gt;f(); // OK here

// Dangerous: reinterpret bits as unrelated type
std::uintptr_t raw = reinterpret_cast&lt;std::uintptr_t&gt;(dp); // address as integer
Derived* fromNum = reinterpret_cast&lt;Derived*&gt;(raw);        // non-portable; avoid
delete b;
}
</code></pre>

        <div class="row g-3">
            <div class="col-lg-6">
            <div class="border rounded p-3 h-100">
                <h4 class="h6">✅ Commonly Allowed & Reasonable</h4>
                <ul class="mb-0">
                <li><code>static_cast&lt;double&gt;(intVal)</code> — widening conversion.</li>
                <li><code>static_cast&lt;int&gt;(doubleVal)</code> — truncates; explicit on purpose.</li>
                <li><code>static_cast&lt;base*&gt;(derivedPtr)</code> — upcast in class hierarchy.</li>
                <li><code>const_cast&lt;T*&gt;</code> — only to call legacy APIs that require non-const (don’t modify truly-const objects).</li>
                </ul>
            </div>
            </div>
            <div class="col-lg-6">
            <div class="border rounded p-3 h-100">
                <h4 class="h6">⛔ Discouraged / Not Allowed / Dangerous</h4>
                <ul class="mb-0">
                <li><strong>Signed overflow</strong> — undefined behavior; not a “cast” problem but a frequent outcome of bad conversions.</li>
                <li><code>reinterpret_cast</code> between unrelated pointer types — non-portable, can break strict aliasing.</li>
                <li><code>const_cast</code> to modify an originally-<code>const</code> object — undefined behavior.</li>
                <li>C-style casts that hide what’s happening — prefer <code>static_cast</code>/<code>const_cast</code>/<code>reinterpret_cast</code>.</li>
                </ul>
            </div>
            </div>
        </div>

        <h3 class="h5 mt-4">Narrowing: What the Compiler Forbids</h3>
<pre><code class="language-cpp">double pi = 3.14159;
// int i{pi};        // ❌ compile-time error: narrowing with brace-init
int j = (int)pi;     // ✅ compiles (C-style), but truncates (explicit)
int k = static_cast&lt;int&gt;(pi); // ✅ compiles, explicit and clear
</code></pre>
        <div class="alert alert-info mb-0">
            <strong>Rule of thumb:</strong> If a conversion might lose information, make it <em>explicit</em> and prefer <code>static_cast</code>.
        </div>
        </div>
    </div> <!-- card -->

    <!-- Practice & Examples -->
    <div class="card shadow-sm h-100">
        <div class="card-body">
        <h2 class="card-title h4">Practice: Spot the Issue</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
unsigned int u = 10;
int s = -1;

auto r1 = u + s;     // what type? what value?
std::cout &lt;&lt; r1 &lt;&lt; '\n';

int big = 3'000'000'000; // fits in 32-bit unsigned, but not 32-bit signed
std::cout &lt;&lt; big &lt;&lt; '\n'; // what happens?

float f = 1e39f;     // overflow to inf on typical IEEE-754 float
std::cout &lt;&lt; f &lt;&lt; '\n';
}
</code></pre>
        <ul class="mb-0">
            <li>Mixed signed/unsigned arithmetic can surprise you (usual arithmetic conversions).</li>
            <li>Integer literal types depend on magnitude and suffix; choose the right type.</li>
            <li>Floating overflow/underflow produce <code>inf</code>/0.0, not compile errors.</li>
        </ul>
        </div>
    </div> <!-- card -->

    <!-- Footer -->
    <div class="text-center text-muted small mt-4">
      <hr />
      <p class="mb-1">
        C++ examples are portable but sizes and exact FP behavior depend on platform and compiler.</p>
      <p class="mb-0">
        Use <code>-std=c++17</code> or later for binary literals and <code>char8_t</code> (C++20).</p>
    </div>
</div> <!-- container -->